# Setup

Deno を利用する

```bash
deno run TypeScript/simple-factory/index.ts
```

# 参照

- https://github.com/sohamkamani/javascript-design-patterns-for-humans

# Pattern type

## Creational Design Pattern

オブジェクト生成の方法を何らかのやり方で制御し、状況に適した方法で生成する仕組みを提供する

- [simple factory](./simple-factory/index.ts)
  - オブジェクトを生成するオブジェクト
  - インスタント生成ロジックは外に露出しない
- [factory method](./factory-method/index.ts)
  - ベースクラスで実装を作り、派生クラスでそれを override する
  - ファクトリーメソッドはそのベースクラスのメソッド
  - ファクトリーメソッドを呼び出してオブジェクトを作成する
  - サブクラス定義時に動的に決定したいときに使う
- [abstract factory](./abstract-factory/index.ts)
  - 共通の目的を持ったファクトリグループを、抽象化することなくカプセル化する
  - グループ化することで、間違ったファクトリを使うことを防ぐ
- [builder](./builder/index.ts)
  - Telescoping constructor アンチパターンの解決策のためのオブジェクト生成パターン
    - Telescoping constructor アンチパターンとは、パラメータが増え続け、パラメータの理解に乏しくなり、このパラメータは今後も拡張し続けていくようになってしまうこと
    - `constructor(size, cheese = true, pepperoni = true, tomato = false, lettuce = true) {...}`
- [prototype](./prototype/index.ts)
  - 既存のオブジェクトをもとにクローンとなるオブジェクトを生成する
- [singleton](./singleton/index.ts)
  - 特定のクラスのインスタンス化を一度だけに制限する
  - アプリケーション全体で統一したい場合にインスタンス化の回数を制限する

## Structual Design Pattern

ソフトウェア・コンポーネントをどのように構築するかの解決法を提案する。  
ソフトウェア工学において、構造的デザインパターンとは、エンティティ間の関係を実現する簡単な方法を明らかにすることで、設計を容易にするデザインパターン

- [adapter](./adapter/index.ts)
  - 既存の処理を別の処理で利用できる形に包む
  - 充電ケーブルの変換アダプタ的な
  - 既存のクラスのインターフェースを別のインターフェースとして利用できるようにする
- [bridge](./bridge/index.ts)
  - 機能と実装を切り離し、両者が独立して変化できるようにする
  - 似たようなサブクラスの量産を防ぐことができる
- [composite](./composite/index.ts)
  - オブジェクトのツリー構造を作成し、それらを 1 つのオブジェクトとして扱う
  - 容器と中身を同一視する
    - フォルダとファイルの関係性
      - フォルダは容器、ファイルは中身
        - フォルダの中にフォルダとファイルがあるとき、フォルダの中のフォルダは「容器」でもあるし「中身」でもある
- [decorator](./decorator/index.ts)
  - 同じクラスの他のオブジェクトの動作に影響を与えることなく、静的または動的に個々のオブジェクトに動作を追加できる
  - オブジェクトをデコレータクラスのオブジェクトでラップすることで、実行時にオブジェクトの振る舞いを動的に変化させることができる
- [facade](./facade/index.ts)
  - 複雑なサブシステムに対して簡素化されたインタフェースを提供する
  - 実際は複雑だけど、窓口は簡素
- [flyweight](./flyweight/index.ts)
  - 他の類似のオブジェクトとできるだけ多くのデータを共有することによって、メモリの使用を最小限に抑えるオブジェクトのこと
  - 単純な繰り返し表現では許容できない量のメモリを使用してしまう場合に、オブジェクトを大量に使用する
- [proxy](./proxy/index.ts)
  - あるクラスが他のクラスの機能を代弁すること
  - ラッパーまたはエージェントオブジェクト経由でクライアントから呼び出され、裏側で実際のオブジェクトにアクセスする
  - プロキシが追加のロジックを提供できる
  - 実際のオブジェクトに対する操作が呼び出される前の前提条件のチェックなどの、特別な機能を提供することができる

## Behavioral Design Pattern

オブジェクト間の責任の分担  
"ある振る舞いをソフトウェアコンポーネントで実行するにはどうすればよいか？"に答える手助けをするもの  
オブジェクト間の共通の通信パターンを特定し、それを実現する設計パターンのことである。そうすることで、この通信を行う際の柔軟性を高める

- [chain of responsibility](./chain-of-responsibility/index.ts)
  - オブジェクトの連鎖を構築
  - リクエストは一方の端から入り、適切なハンドラを見つけるまでオブジェクトからオブジェクトへと移動し続ける。
- [command](./command/index.ts)
  - アクションをオブジェクトにカプセル化
  - クライアントとレシーバーを切り離す手段を提供する
  - クライアントとインヴォーカーは接するが、アクションを実行するレシーバーとクライアントは接点を持たない
  - レシーバーにアクションしてもらうために、クライアントはインヴォーカーを使役する
- [iterator](./iterator/index.ts)
  - オブジェクトの要素にアクセスする際に、その基盤となるプレゼンテーションを公開しない方法を提示
  - ある集合体の要素 1 つ 1 つに、順次アクセスする方法を提供するが、その詳細は公開しない
  - コンテナを走査し、コンテナの要素にアクセスするためにイテレータを使用する
- [mediator](./mediator/index.ts)
  - 2 つのオブジェクト（collague と呼ぶ）間の相互作用を制御するために、第三者のオブジェクト（mediator と呼ぶ）を追加する
  - 互いに通信するクラス間の結合を減らすのに役立つ
    - 互いの実装に関する知識を持つ必要がなくなるため
  - 一連のオブジェクトがどのように相互作用するかをカプセル化したオブジェクトを定義する
- [memento](./memento/index.ts)
  - オブジェクトの現在の状態を捉えて保存し、後でスムーズに復元できるようにする
  - オブジェクトを以前の状態に戻す（ロールバックによるアンドゥ）機能を提供するソフトウェアのデザインパターン
- [observer](./observer/index.ts)
  - pubsub とも言う
  - あるオブジェクトが状態を変更するたびに、その依存するすべてのオブジェクトが通知される
  - オブジェクトがオブザーバーと呼ばれる依存者のリストを保持し、状態の変化を自動的に通知する
- [visitor](./visitor/index.ts)
  - オブジェクトに手を加えることなく、さらに操作を追加することができる
  - アルゴリズムとそれを操作するオブジェクト構造を分離する
  - オープン/クローズの原則に従う方法の 1 つ
- [strategy](./strategy/index.ts)
  - policy pattern とも言う
  - 状況に応じてアルゴリズムやストラテジーを切り替えることができる
  - アルゴリズムの振る舞いを実行時に選択できるようにする
- [state](./state/index.ts)
  - ステートマシンをオブジェクト指向で実装する動作ソフトウェアデザインパターン
  - 個々の状態をステートパターンインタフェースの派生クラスとして実装し、パターンのスーパークラスで定義されたメソッドを呼び出すことで状態遷移を実装
  - パターンのインタフェースで定義されたメソッドの呼び出しによって現在の戦略を切り替えることができる戦略パターンとして解釈することができる
- [template method](./template-method/index.ts)
  - あるアルゴリズムがどのように実行されるかの骨格を定義し、サブクラスに実装の処理の具体を移譲する
  - アルゴリズムのプログラムスケルトンを演算で定義し、いくつかのステップをサブクラスに委ねる動作設計パターン
  - これにより、アルゴリズムの構造を変更することなく、アルゴリズムの特定のステップを再定義することができる
