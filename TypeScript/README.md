# Setup

Deno を利用する

```bash
deno run TypeScript/simple-factory/index.ts
```

# 参照

- https://github.com/sohamkamani/javascript-design-patterns-for-humans

# Pattern type

## Creational Design Pattern

オブジェクト生成の方法を何らかのやり方で制御し、状況に適した方法で生成する仕組みを提供する

- [simple factory](./simple-factory/index.ts)
  - オブジェクトを生成するオブジェクト
  - インスタント生成ロジックは外に露出しない
- [factory method](./factory-method/index.ts)
  - ベースクラスで実装を作り、派生クラスでそれを override する
  - ファクトリーメソッドはそのベースクラスのメソッド
  - ファクトリーメソッドを呼び出してオブジェクトを作成する
  - サブクラス定義時に動的に決定したいときに使う
- [abstract factory](./abstract-factory/index.ts)
  - 共通の目的を持ったファクトリグループを、抽象化することなくカプセル化する
  - グループ化することで、間違ったファクトリを使うことを防ぐ
- [builder](./builder/index.ts)
  - Telescoping constructor アンチパターンの解決策のためのオブジェクト生成パターン
    - Telescoping constructor アンチパターンとは、パラメータが増え続け、パラメータの理解に乏しくなり、このパラメータは今後も拡張し続けていくようになってしまうこと
    - `constructor(size, cheese = true, pepperoni = true, tomato = false, lettuce = true) {...}`
- [prototype](./prototype/index.ts)
  - 既存のオブジェクトをもとにクローンとなるオブジェクトを生成する
- [singleton](./singleton/index.ts)
  - 特定のクラスのインスタンス化を一度だけに制限する
  - アプリケーション全体で統一したい場合にインスタンス化の回数を制限する

## Structual Design Pattern

ソフトウェア・コンポーネントをどのように構築するかの解決法を提案する。  
ソフトウェア工学において、構造的デザインパターンとは、エンティティ間の関係を実現する簡単な方法を明らかにすることで、設計を容易にするデザインパターン

- [adapter](./adapter/index.ts)
  - 既存の処理を別の処理で利用できる形に包む
  - 充電ケーブルの変換アダプタ的な
  - 既存のクラスのインターフェースを別のインターフェースとして利用できるようにする
- [bridge](./bridge/index.ts)
  - 機能と実装を切り離し、両者が独立して変化できるようにする
  - 似たようなサブクラスの量産を防ぐことができる
- [composite](./composite/index.ts)
  - オブジェクトのツリー構造を作成し、それらを 1 つのオブジェクトとして扱う
  - 容器と中身を同一視する
    - フォルダとファイルの関係性
      - フォルダは容器、ファイルは中身
        - フォルダの中にフォルダとファイルがあるとき、フォルダの中のフォルダは「容器」でもあるし「中身」でもある
- [decorator](./decorator/index.ts)
  - 同じクラスの他のオブジェクトの動作に影響を与えることなく、静的または動的に個々のオブジェクトに動作を追加できる
  - オブジェクトをデコレータクラスのオブジェクトでラップすることで、実行時にオブジェクトの振る舞いを動的に変化させることができる
- [facade](./facade/index.ts)
  - 複雑なサブシステムに対して簡素化されたインタフェースを提供する
  - 実際は複雑だけど、窓口は簡素
- [flyweight](./flyweight/index.ts)
  - 他の類似のオブジェクトとできるだけ多くのデータを共有することによって、メモリの使用を最小限に抑えるオブジェクトのこと
  - 単純な繰り返し表現では許容できない量のメモリを使用してしまう場合に、オブジェクトを大量に使用する
- [proxy](./proxy/index.ts)
  - あるクラスが他のクラスの機能を代弁すること
  - ラッパーまたはエージェントオブジェクト経由でクライアントから呼び出され、裏側で実際のオブジェクトにアクセスする
  - プロキシが追加のロジックを提供できる
  - 実際のオブジェクトに対する操作が呼び出される前の前提条件のチェックなどの、特別な機能を提供することができる

## Behavioral Design Pattern

オブジェクト間の責任の分担  
"ある振る舞いをソフトウェアコンポーネントで実行するにはどうすればよいか？"に答える手助けをするもの  
オブジェクト間の共通の通信パターンを特定し、それを実現する設計パターンのことである。そうすることで、この通信を行う際の柔軟性を高める

- [chain of responsibility](./chain-of-responsibility/index.ts)
  - オブジェクトの連鎖を構築
  - リクエストは一方の端から入り、適切なハンドラを見つけるまでオブジェクトからオブジェクトへと移動し続ける。
- [command](./command/index.ts)
  - アクションをオブジェクトにカプセル化
  - クライアントとレシーバーを切り離す手段を提供する
  - クライアントとインヴォーカーは接するが、アクションを実行するレシーバーとクライアントは接点を持たない
  - レシーバーにアクションしてもらうために、クライアントはインヴォーカーを使役する
- [iterator](./iterator/index.ts)
  - オブジェクトの要素にアクセスする際に、その基盤となるプレゼンテーションを公開しない方法を提示
  - ある集合体の要素 1 つ 1 つに、順次アクセスする方法を提供するが、その詳細は公開しない
  - コンテナを走査し、コンテナの要素にアクセスするためにイテレータを使用する
- [mediator](./mediator/index.ts)
  - 2 つのオブジェクト（collague と呼ぶ）間の相互作用を制御するために、第三者のオブジェクト（mediator と呼ぶ）を追加する
  - 互いに通信するクラス間の結合を減らすのに役立つ
    - 互いの実装に関する知識を持つ必要がなくなるため
  - 一連のオブジェクトがどのように相互作用するかをカプセル化したオブジェクトを定義する
